using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Networking;

public class AllTerrain : NetworkBehaviour {

	public static AllTerrain AT;
	[SyncVar] public string seed;
	[HideInInspector] public System.Random pRandom;
	public int mapWidth;
	public int mapHeight;
	public int minPeek;
	public int maxPeek;
	public int midpointRange;
	public int startZoneWidth;
	public int startZoneHeight;
	public Color32 topColor;
	public int topColorDepth;
	public Color32 botColor;
	[HideInInspector] public Color[] colorMap;

	private SpriteRenderer sr;
	private Texture2D tex;

	public override void OnStartServer() {
		seed = Random.value.ToString ();
	}

	void Awake() {
		AT = this;
	}

	void Start () {
		sr = GetComponent<SpriteRenderer> ();
		tex = new Texture2D (mapWidth, mapHeight);
		tex.filterMode = FilterMode.Point;

		pRandom = new System.Random(seed.GetHashCode());
		colorMap = new Color[mapWidth * mapHeight];
		CreateNewMap ();
		UpdateMap ();

		Sprite s = Sprite.Create (tex, new Rect (0, 0, mapWidth, mapHeight), Vector2.zero, 1);
		s.name = "AutoGenerated";
		sr.sprite = s;
	}

	public void UpdateMap() {
		tex.SetPixels (colorMap);
		tex.Apply ();
	}
	
	void CreateNewMap() {
		float px = pRandom.Next (0, 999) / mapWidth;
		float py = pRandom.Next (0, 999) / mapHeight;
		float scale = 10;
		float colorRange = 45;

		// Left start zone
		for (int x = 0; x < startZoneWidth; x++) {
			// Bottom
			for (int bot = 0; bot < startZoneHeight-topColorDepth; bot++) {
				colorMap [bot * mapWidth + x] = new Color((botColor.r - Mathf.PerlinNoise (px+x/scale,py+bot/scale) * colorRange) / 255, 
					(botColor.g - Mathf.PerlinNoise (px+x/scale,py+bot/scale) * colorRange) / 255,
					(botColor.b - Mathf.PerlinNoise (px+x/scale,py+bot/scale) * colorRange) / 255, 
				1);
			}
			// Top
			for (int top = startZoneHeight-topColorDepth; top < startZoneHeight; top++) {
				colorMap [top * mapWidth + x] = topColor;	
			}

		}
		// Right start zone
		for (int x = mapWidth-startZoneWidth; x < mapWidth; x++) {
			// Bottom
			for (int bot = 0; bot < startZoneHeight-topColorDepth; bot++) {
				colorMap [bot * mapWidth + x] = new Color((botColor.r - Mathf.PerlinNoise (px+x,py+bot) * colorRange) / 255, 
					(botColor.g - Mathf.PerlinNoise (px+x/scale,py+bot/scale) * colorRange) / 255,
					(botColor.b - Mathf.PerlinNoise (px+x/scale,py+bot/scale) * colorRange) / 255, 
					1);
			}
			// Top
			for (int top = startZoneHeight-topColorDepth; top < startZoneHeight; top++) {
				colorMap [top * mapWidth + x] = topColor;	
			}

		}

		// The middle ground
		Vector2[] heights = HeightMap();
		int[] h = new int[heights.Length];
		for (int i = 0; i < heights.Length; i++) {
			h [i] = (int)heights [i].y;
		}

		for (int x = startZoneWidth; x < mapWidth-startZoneWidth; x++) {
			// Bottom
			for (int bot = 0; bot < h[x-startZoneWidth]-topColorDepth; bot++) {
				colorMap [bot * mapWidth + x] = new Color((botColor.r - Mathf.PerlinNoise (px+x,py+bot) * colorRange) / 255, 
					(botColor.g - Mathf.PerlinNoise (px+x/scale,py+bot/scale) * colorRange) / 255,
					(botColor.b - Mathf.PerlinNoise (px+x/scale,py+bot/scale) * colorRange) / 255, 
					1);
			}
			// Top
			for (int top = h[x-startZoneWidth]-topColorDepth; top < h[x-startZoneWidth]; top++) {
				colorMap [top * mapWidth + x] = topColor;	
			}
		}
	}

	Vector2[] HeightMap() {
		int midx = mapWidth / 2 +  pRandom.Next (-midpointRange, midpointRange);
		int peek = pRandom.Next (minPeek, maxPeek);
		int newX, newY;
		List<Vector2> heights = new List<Vector2> ();
		heights.Add (new Vector2(startZoneWidth, startZoneHeight));
		heights.Add (new Vector2 (midx, peek));
		heights.Add (new Vector2(mapWidth-startZoneWidth, startZoneHeight));

		for (int n=0; n < heights.Count-1; n++)
		{
			// if the distance between terrain[n] X and terrain[n+1] X > 0, generate more terrain
			int diff = (int)heights[n+1].x - (int)heights[n].x;
			if (diff > 1)
			{ 
				newX = (int)heights[n].x + Mathf.FloorToInt((diff / 2));
				newY = pRandom.Next((int)Mathf.Min(heights[n].y, heights[n+1].y), (int)Mathf.Max (heights[n].y, heights[n+1].y));
				heights.Insert(n+1, new Vector2(newX, newY));
				n--;
			}	
		}

		return heights.ToArray();
	}

}